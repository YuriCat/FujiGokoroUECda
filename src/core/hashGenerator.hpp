/*
 hashGenerator.hpp
 Katsuki Ohto
 */
#pragma once

#include <cassert>

namespace UECda{
    
    // ハッシュ値生成
    // とりあえず生成関数を毎回呼べば動くだろうが、
    // １からの計算は出来る限り避けるように
    
    /**************************カード整数**************************/
    
    constexpr uint64_t cardsHashKeyTable[64] = {
        // インデックスがIntCard番号に対応
        // generated by SFMT
        0x15cc5ec4cae423e2, 0xa1373ceae861f22a, 0x7b60ee1280de0951, 0x970b602e9f0a831a,
        0x9c2d0e84fa38fd7b, 0xf8e8f5de24c6613c, 0x59e1e0ec5c2dcf0f, 0xee5236f6cc5ecd7c,
        0x955cdae1107b0a6f, 0x664c969fef782110, 0x131d24cfbc6cc542, 0x4747206ff1446e2c,
        0x02ea232067f62eec, 0xb53c73b144873900, 0x62623a5213bdae74, 0x655c7b3f43d2ea77,
        0x4e4f49ed97504cd0, 0x62e37cdd7416e4d1, 0x8d82596514f50486, 0x85eeb4e5f361ad26,
        0xca376df878e7b568, 0x012caaf9c1c68d82, 0x9ae28611b76ac1d6, 0xe8b42904d7ac4688,
        0x50ebe782f7343538, 0xf2876e2b5a0d5da5, 0xf308e93cd29a1fb5, 0x3e58ae2a9e1fb64a,
        0x143a9b63f5128d58, 0xd7e31ea845745bf5, 0xcc59315a5031ae64, 0x77591890cfbe493a,
        0xea239dd1932bfc0b, 0xbb4a9b581dc50a58, 0xd7640b6cb72a9798, 0x537b3fcac53dcefc,
        0xa52fb140c73cc931, 0xd123cf73f9aab466, 0x6eed725d80ead216, 0x151b7aa1f03f0532,
        0xfba74ec660ed2e46, 0x8aa22769ccf87343, 0x1896000f642b41ac, 0x97b0de139c5b487c,
        0x20a10996d700d1b3, 0x76e8529b3f3d425e, 0xf48b294add39ea07, 0x1abdb74a2202e8ea,
        0xff502998b9aed7e7, 0x6629aa61eb40d7e0, 0x87e72aef918d27b7, 0xf1b25fdda49f70bd,
        0xb10abbc401dd1e03, 0xb9ddbad67b370949, 0xefa07417c6906e38, 0x1616cec390c9db9f,
        0xb048124c6ef48ff5, 0x65978b47dbc1debb, 0x925e60277ee19bbf, 0xed776c6b664087e8,
        0x29bf249af2b02a7b, 0xc64ed74ce9ea7c77, 0xc05774752bed93f3, 0x5fc31db82af16d07,
    };
    
    uint64_t IntCardToHashKey(IntCard ic)noexcept{
        assert(0 <= ic && ic < 64);
        return cardsHashKeyTable[ic];
    }
    
    /**************************カード集合**************************/
    
    // 一枚一枚に乱数をあてたゾブリストハッシュ値を用いる
    // 線形のため合成や進行が楽
    // 一方0からの計算は枚数に対して線形時間なので末端処理では厳禁
    
    constexpr uint64_t HASH_CARDS_NULL = 0ULL;
    constexpr uint64_t HASH_CARDS_ALL = 0xe59ef9b1d4fe1c44ULL; // 先に計算してある
    
    
    uint64_t CardToHashKey(Cards c)noexcept{
        // Cards型で、1枚の場合
        assert(countCards(c) == 1);
        return IntCardToHashKey(CardsToLowestIntCard(c));
    }
    
    uint64_t CardsToHashKey(Cards c)noexcept{
        // Cards型一般
        uint64_t key = HASH_CARDS_NULL;
        while(anyCards(c)){
            key ^= IntCardToHashKey(popIntCardLow(&c));
        }
        return key;
    }
    
    uint64_t OtherCardsToHashKey(Cards c)noexcept{
        // Cards型、全体から引いたもの
        uint64_t key = HASH_CARDS_ALL;
        while(anyCards(c)){
            key ^= IntCardToHashKey(popIntCardLow(&c));
        }
        return key;
    }
    
    /**************************複数のカード集合**************************/
    
    // 交換不可能なもの
    
    // 支配保証判定など、複数のカード集合間に成立する関係を保存する場合に使うかも
    uint64_t CardsCardsToHashKey(Cards c0, Cards c1)noexcept{
        return crossBits64(CardsToHashKey(c0), CardsToHashKey(c1));
    }
    
    uint64_t knitCardsCardsHashKey(uint64_t key0, uint64_t key1)noexcept{
        return crossBits64(key0, key1);
    }
    
    template<int N>
    uint64_t CardsArrayToHashKey(const Cards c[]){
        uint64_t hash_c[N];
        for(int n = 0; n < N; ++n){
            hash_c[n] = CardsToHashKey(c[n]);
        }
        return crossBits64<N>(hash_c);
    }
    
    template<int N>
    uint64_t knitCardsArrayHashKey(const Cards hash_c[]){
        return crossBits64<N>(hash_c);
    }
    
    template<int N>
    uint64_t procCardsArrayHashKey(const uint64_t okey, const int n, const uint64_t dkey){
        return procCrossedHash<N>(okey, n, dkey);
    }
    
    // 交換可能なもの
    // 最小のハッシュ値を採用すれば良いだろう
    
    /**************************場**************************/
    
    // 場役の情報 + 誰がパスをしたかの情報
    
    // 空場
    // 空場のときは、場の変数はオーダー関連だけである事が多いのでそのまま
    constexpr uint64_t NullBoardToHashKey(Board bd)noexcept{
        return (uint64_t)bd;
    }
    constexpr uint64_t NullStateToHashKey(uint64_t aliveKey, uint64_t fullAwakeKey,
                                          PlayersState ps, int ntp)noexcept{
        return aliveKey ^ fullAwakeKey ^ ntp;
    }
    
    // 通常場
    // パスをしたプレーヤーの分のハッシュを加算
    constexpr uint64_t awakeHashKeyTable[8] = {
        0x53a3c531204f44cd, 0x6c8928b9fde6ffe2, 0x5896fab81fa48c9e, 0x721fa3f0d39cdbe3,
        0x19bdf3ac3a750ce7, 0x79bf388066e9db41, 0xc15d97a4586c07e8, 0x45c2bb247f4ecf6e,
    };
    // 上がったプレーヤーの分のハッシュを加算
    constexpr uint64_t deadHashKeyTable[8] = {
        0x9fc68859bb0b6965, 0xfdd58e05463f7894, 0xbd2e7d5e7d71521c, 0xeb3669cb8f72e2aa,
        0x237395283fc3e25a, 0x56564d4dda42ec2a, 0x7786549ce8365630, 0x0e338bf62ab5547e,
    };
    
    uint64_t BoardToHashKey(Board bd)noexcept{
        return (uint32_t)bd & (MOVE_FLAG_CHARA | MOVE_FLAG_STATUS);
    }
    uint64_t StateToAliveHashKey(PlayersState ps)noexcept{
        uint64_t key = 0;
        for(int p = 0; p < N_PLAYERS; ++p){
            if(!ps.isAlive(p))key ^= deadHashKeyTable[p];
        }
        return key;
    }
    uint64_t StateToFullAwakeHashKey(PlayersState ps)noexcept{
        uint64_t key = 0;
        for(int p = 0; p < N_PLAYERS; ++p){
            if(ps.isAlive(p))key ^= awakeHashKeyTable[p];
        }
        return key;
    }
    uint64_t StateToHashKey(uint64_t aliveKey, PlayersState ps, int ntp)noexcept{
        uint64_t key = aliveKey;
        for(int p = 0; p < N_PLAYERS; ++p){
            if(ps.isAwake(p))key ^= awakeHashKeyTable[p];
        }
        return key ^ ntp;
    }
    uint64_t procStateHashKeyNonPass(uint64_t okey, int p, int ntp)noexcept{
        return okey ^ p ^ ntp;
    }
    uint64_t procStateHashKeyPass(uint64_t okey, int p, int ntp)noexcept{
        assert(0 <= p && p < N_PLAYERS);
        return okey ^ awakeHashKeyTable[p] ^ p ^ ntp;
    }
    
    /**************************カード枚数**************************/
    
    // 0 ~ 15枚に対応
    constexpr uint64_t numCardsHashHeyTable[16] = {
        0x0000000000000000, 0x235d584e87d9078c, 0x8dee06ab61dbe55d, 0x42704b391af8fd37,
        0xb637b1a984b2e4ac, 0x91ad63603ea5a497, 0x5540b3f9c0d3cae7, 0xfba4e6170253df41,
        0xafa83b2ae020a824, 0x3ca273b44b74028b, 0x958e166a932f45ef, 0xb6ff5e23ee54256f,
        0xd2842d9109e968f6, 0xd32573c345c1a9bd, 0x22f9bd8203e770ed, 0x5a54859f5974cf6f,
    };
    
    // N を対象人数とする
    template<int N, class callback_t>
    uint64_t NumCardsToHashKey(const callback_t& callback){
        // callbackはプレーヤー番号を引数にとって手札枚数を返す関数
        uint64_t key = 0ULL;
        for(int p = 0; p < N; ++p){
            int nc = callback(p);
            ASSERT(0 <= nc && nc < 16, cerr << nc << endl;);
            key |= numCardsHashHeyTable[nc] & genCrossNumber<N>(p);
        }
        return key;
    }
    
    template<int N>
    uint64_t procNumCardsHashKey(uint64_t hash, int p, uint32_t new_nc){
        ASSERT(0 <= new_nc && new_nc < 16, cerr << new_nc << endl;);
        ASSERT(0 <= p && p < N, cerr << p << "(" << N << ")" << endl;);
        const uint64_t mask = genCrossNumber<N>(p);
        return (hash & ~mask) | (numCardsHashHeyTable[new_nc] & mask);
    }
    
    
    /**************************局面:L2**************************/
    
    // 完全情報局面なのでシンプルな後退ハッシュ値
    // 先手、後手の順番でカード集合ハッシュ値をクロスして場のハッシュ値を線形加算
    // ただしNFでない場合パスと場主も考慮が必要なので、現在はやってない
    
    constexpr uint64_t L2PassHashKeyTable[2] = {
        0x9a257a985d22921b, 0xe8237fa57f5d50ed,
    };
    
    uint64_t L2NullFieldToHashKey(Cards c0, Cards c1, Board bd){
        return CardsCardsToHashKey(c0, c1) ^ NullBoardToHashKey(bd);
    }
    
    // すでにハッシュ値が部分的に計算されている場合
    uint64_t knitL2NullFieldHashKey(uint64_t ckey0, uint64_t ckey1, uint64_t boardKey){
        return knitCardsCardsHashKey(ckey0, ckey1) ^ boardKey;
    }
    
    /**************************局面:Ln完全情報**************************/
    
    // L2以外で、神視点から局面を見た際のハッシュ値
    // 探索結果の再利用や完全情報仮定しての求解に利用
    
    // L2と同じ構成方法だが、クロスの順番を手番ではなく主観的なものにしたい場合には手番情報などを追加した方が良い

    // すでにハッシュ値が部分的に計算されている場合
    constexpr uint64_t knitHash_L3CI_NF(uint64_t h0, uint64_t h1, uint64_t h2,
                                        Board bd)noexcept{
        return crossHash(h0, h1, h2) ^ NullBoardToHashKey(bd);
    }
    
    constexpr uint64_t knitHash_L4CI_NF(uint64_t h0, uint64_t h1,
                                        uint64_t h2, uint64_t h3,
                                        Board bd)noexcept{
        return crossHash(h0, h1, h2, h3) ^ NullBoardToHashKey(bd);
    }
    
    constexpr uint64_t knitHash_L5CI_NF(uint64_t h0, uint64_t h1, uint64_t h2,
                                        uint64_t h3, uint64_t h4,
                                        Board bd)noexcept{
        return crossHash(h0, h1, h2, h3, h4) ^ NullBoardToHashKey(bd);
    }
    
    
    template<int N>
    uint64_t knitHash_LnCI(const uint64_t hash_c[], uint64_t hash_bd){
        return crossHash<N>(hash_c) ^ hash_bd;
    }
    
    
    /**************************局面:Ln後退主観情報**************************/
    
    // 後退情報のハッシュ値
    // 必勝、必敗といった順位確定処理などに用いる
    // 交換等の関係で、完全判別を目指すと多くの情報を使う事になる
    // 不完全な方を使う方が見落としはあるが楽
    
    // 情報
    // 自分の手札(カード集合)
    // 自分以外のプレーヤーが持っている手札
    // 場
    // 手札枚数
    
    // 後退情報
    constexpr uint64_t knitHash_RetInfo(uint64_t hash_mine,
                                        uint64_t hash_ops,
                                        uint64_t hash_ncards)noexcept{
        return crossHash(hash_mine, hash_ops) ^ hash_ncards;
    }
    
    /*uint64_t procHash_RetInfo_myCards( uint64_t hash, uint64_t hash_mine ){
     return hash ^ (hash_mine&genCrossNumber<2>(0));
     }
     
     uint64_t procHash_RetInfo_opsCards( uint64_t hash, uint64_t hash_ops ){
     return hash ^ (hash_ops&genCrossNumber<2>(1));
     }
     */
    
    
    
    /*
     uint64_t genHash_RetField(Cards mine,Cards ops,Board bd){
     //最も単純なもの
     return crossHash(genHash_Cards(mine),genHash_Cards(ops))^genHash_Board(bd);
     }
     */
    
    constexpr uint64_t knitRetFieldHashKey(uint64_t hash_mine,
                                           uint64_t hash_ops,
                                           uint64_t hash_ncards,
                                           uint64_t hash_bd)noexcept{
        return crossHash(hash_mine, hash_ops) ^ hash_ncards ^ hash_bd;
    }
    
    constexpr uint64_t knitRetFieldHashKey(uint64_t hash_ri,
                                           uint64_t hash_bd)noexcept{
        return hash_ri ^ hash_bd;
    }
    
    /**************************局面:Ln前進主観情報**************************/
    
    // 前進情報のハッシュ値
    // 先読み時に局面を登録することで、枝刈りやオーダリングを何度も行うのを避けたり、
    // 同じ局面を精査するたびに読みを深めるなどするために使う
    
    // 実際には思考時間のように連続的な情報も試合で得る事が出来るので、真の完全判別は不可能。
    // 試合中の棋譜進行によって判別する
    // しかし分ける意味が薄そうな場合もあるので、
    // どこまで詳しく分けるかは検討の必要あり
    
    // 現在は各プレーヤーがこれまでに使用したカードによって進行を表現
    // そのため、どのような順番でカードが出されたかは不問としており、
    // 必勝逃しなどの判断は出来ない
    
    // 実際の試合であがったプレーヤーの情報を外すかは要検討
    // 外すと衝突が減るが、あがりが出た際にそれまでのハッシュ値との互換性が無くなる
    
    // 情報
    // 自分の手札(カード集合)
    // 自分以外の各プレーヤーが使用したカード集合
    // 場
    
    /*template<int N>
     uint64_t genHash_LnSbjProField_NF(Cards myOrg,Cards used[],Board bd){
     //最も単純なもの
     return genHash_Cards(myOrg) ^ crossHash(genHash_nCards<N>(used)) ^ genHash_Board_NF(bd);
     }
     */
    
    constexpr uint64_t knitLnSbjProFieldHashKey(uint64_t hash_org,
                                                uint64_t hash_used,
                                                uint64_t hash_bd)noexcept{
        // 最も単純なもの
        return hash_org ^ hash_used ^ hash_bd;
    }
    /*
     template<int N>
     uint64_t procHash_LnSbjProField(uint64_t hash,int p,Cards c,Board lastB,Board newB){
     // 進行
     assert(0 <= p && p < N);
     return hash^(genHash_Cards(c) & genCrossNumber<N>(p)) ^ genHash_Board(lastB) ^ genHash_Board(newB);
     }
     */
}